---
layout: post
title: "SRM 416"
description: ""
category: Algorithm
tags: [SRM, Algorithm]
---
{% include JB/setup %}
###Description###
250-points: Give you some strings, you should return the most frequent letters in the strings.

500-points: Give you a number n, you should return the smallest number r, r is bigger than n and has the same number of 1 with n in binary.

1000-points: Give you a Matrix m hold the relationship of boys and girls and a number K, if `m[i][j] == 1` then boy i can be paired with girl j, and 0 otherwise. You should return the number of distinct valid ways to select exactly K boy-girl pairs.

###Algorithm###
250-points: Just go through the strings and count eache letter's count, return the most frequent of them.

500-points: First, you should get the number of 1 in n's binary, then find the rightest(the right is the low bit) bit with 1 in n's binary, and keep going until a bit with 0 in n's binary, then replace the 0 with 1 and put the other 1s in the rightest. For example, n=47 with binary 101110, first we find the rightest 1 in n's binary, we got the second bit from the right, and keep going until a bit with 0 in n's binary, we got the fifth bit from the right, so we replace the 0 with 1, now, we get a number in binary 111110, the number of 1s in this number in binary is more than 47, so we put another two 1in 110000, because 110000 guarantee the number we get is bigger than n, in this case, we only to put anoter two 1 in the rightest of 110000, so we can get the smallest number. There is a nice way to get the rightest 1 in n : `n&-n`, you can view the details in [there](http://www.cppblog.com/klion/archive/2010/05/24/116240.html).

1000-points: In the first sight, I think this is a search problme, and write the code blow:
	
	void search(int n, in k) // n is the boy we search now, k is the pairs we still need
		{
			if(k<1)	//there are already K(the pairs we need) pairs
				{
					++ret;  //ret is the answer we want to get
					return ;		
				}
			if(n>=R)	//boys are all searched
				return ;
			if(k>R-n+1) // the last boys and girls can't satisfy the K condition
				return ;
			int t[10];
			search(n+1, k);	//this boy is not in any pairs
			for(int j=0;j<C;++j)	//C is the number of girls
			{
				if(dance[n][j] == 1)
				{
					for(int i=0;i<R;++i)
					{
						t[i] = dance[i][j];
						dance[i][j] = 0;
					}
					search(n+1, k-1);//this boy is paired with girl j
					for(int i=0;i<R;++i)
						dance[i][j] = t[i];
				}
			}
		}

but Time-Limit-Exceed in the case has 10 boys and 10 girls, and each boy can be paired with each girl, the K equals to 10. In these cases matrix items are all 1, we could use the formula `fac[R]*fac[C]/(fac[R-K]*fac[C-K]*fac[K])` to calculate the answer, but this is a trick way, if there is only a 1 in the matrix, this way can't work.

